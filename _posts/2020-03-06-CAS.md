---
layout:     post
title:      CAS 
subtitle:   Java 并发学习系列博客
date:       2020-03-06
author:     GJXAIOU 
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Java并发
---



# CAS

## 一、概念与原理

- CAS (Compare And Swap)，即比较并交换。是**解决多线程并行情况下使用锁造成性能损耗的一种机制**。

- **CAS 比较交换的过程**涉及三个操作数分别为：内存地址存放的实际值；预期的值；更新的新值。当内存地址的值的预期的值相同时，也就是说旧值和内存中实际的值相同，表明该值没有被其他线程更改过，那么处理器会自动将该位置值更新为新值。反之，如果内存地址的值和预期的值不相同，表明该值已经被其他线程改过了，不做任何操作，返回内存位置的值即可。当多个线程使用 CAS 操作一个变量时候，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，也可以选择挂起线程。

- CAS 的实现需要硬件指令集的支撑，在 JDK1.5 后虚拟机才可以使用处理器提供的 CMPXCHG 指令实现。

    

## 二、atomic 包原理

atomic 包提供原子更新类型的工具类，其中 A 指一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

### 根据操作的数据类型，可以将 JUC 包中的原子类分为4类

- 基本类型：使用原子的方式更新基本类型

    AtomicInteger：整型原子类；AtomicLong：长整型原子类；AtomicBoolean ：布尔型原子类

- 数组类型：使用原子的方式更新数组里的某个元素

    AtomicIntegerArray：整型数组原子类；AtomicLongArray：长整型数组原子类；AtomicReferenceArray ：引用类型数组原子类

- 引用类型

    - AtomicReference：引用类型原子类
    - AtomicReferenceFieldUpdater：原子更新引用类型里的字段
    - AtomicMarkableReference ：原子更新带有标记位的引用类型

- 对象的属性修改类型

    - AtomicIntegerFieldUpdater:原子更新整型字段的更新器
    - AtomicLongFieldUpdater：原子更新长整型字段的更新器
    - AtomicStampedReference ：原子更新带有版本号的引用类型。
    - AtomicMarkableReference：原子更新带有标记的引用类型

**原理**：

AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

Unsafe 类在 sun.misc 包下，Unsafe 类提供了一些底层操作，**atomic 包下的原子操作类的主要是通过 Unsafe 类提供的 compareAndSwapInt，compareAndSwapLong 等一系列提供 CAS 操作的方法来进行实现**。

## 三、乐观锁与悲观锁

- 使用锁时，**线程获取锁是一种悲观锁策略**：即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时会阻塞其他线程获取该锁。
- **无锁操作：使用 CAS 来鉴别线程是否出现冲突，是一种乐观锁策略**，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。当然出入出现了冲突就重试当前操作直到没有冲突位置。

## 四、CAS 的 ABA 与自旋时间过长问题

- ABA 问题

    **在 CAS 算法中，需要取出内存中某时刻的数据（由用户完成），在下一时刻比较并替换（由 CPU 完成，该操作是原子的），这个时间差中，会导致数据的变化。**

    > 假设如下事件序列：
    >
    > 线程 1 从内存位置 V 中取出 A。
    >
    > 线程 2 从位置 V 中取出 A。
    >
    > 线程 2 进行了一些操作，将 B 写入位置 V。
    >
    > 线程 2 将 A 再次写入位置 V。
    >
    > 线程 1 进行 CAS 操作，发现位置 V 中仍然是 A，操作成功。

尽管线程 1 的 CAS 操作成功，但不代表这个过程没有问题——对于线程 1 ，线程 2 的修改已经丢失。    

**解决方案**可以沿袭数据库中常用的乐观锁方式，**添加一个版本号**可以解决。**Java 在 AtomicStampedReference 类中除了对象值，其内部还维护了一个“状态戳”（可以理解为版本号）**。状态戳可类比为时间戳，是一个整数值，每一次修改对象值的同时，也要修改状态戳，从而区分相同对象值的不同状态。
当 AtomicStampedReference 设置对象值时，通过 compareAndSet() 方法会验证：期望值 写入新值 期望时间戳 新时间戳，只有**对象值以及状态戳都必须满足期望值**，写入才会成功。

- 自旋时间过长

    使用 CAS 时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果 JVM 能支持处理器提供的 pause 指令，那么在效率上会有一定的提升。

