---
layout:     post
title:      Java 内存模型之缓存一致性问题
subtitle:   Java 并发学习系列博客
date:       2020-03-11
author:     GJXAIOU 
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Java 并发
    - 缓存一致性
---

## Java 内存模型之缓存一致性问题

Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

### （一）主内存与工作内存

- **高速缓存**：处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。

- **所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中**，保存了该线程使用的变量的主内存副本拷贝。

- **线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。**

#### 1.缓存一致性(MESI 原则)

- **MESI 协议为了保证多个 CPU 的 Cache 之间缓存共享数据的一致**，定义了 Cache Line 四种状态，而 CPU 对 Cache 的四种操作可能造成不一致的状态， 因此缓存控制器监听到本次操作和远程操作之后需要对地址一定的 Cache Line 的状态做出一定的修改，从而保证数据在缓多个位置的一致性。


| 状态描述          | 说明                                                         | 描述                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| M: Modified 修改  | 该 Cache line 有效，数据被修改了，**和内存中的数据不一致**，数据只存在于**本 Cache**中。 | 该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。 当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。 |
| E：Exclusive 独享 | 该 Cache line 有效，数据**和内存中的数据一致**，数据只存在于**本 Cache **中。 | 该状态可以在任何时刻当有其它 CPU 读取该内存时变成共享状态（shared)。 同样地，当CPU修改该缓存行中内容时，该状态可以变成 Modified 状态。 |
| S：Share 共享     | 该 Cache line 有效，数据**和内存中的数据一致**，数据存在于**很多 Cache **中。 | 当有一个 CPU 修改该缓存行中，其它 CPU 中该缓存行可以被作废（变成无效状态（Invalid））。 |
| I:Invalid 无效    | 该Cache line无效。                                           | 无                                                           |

* 触发事件:（CPU 对缓存的四种操作）

| 触发事件                 | 描述                           |
| ------------------------ | ------------------------------ |
| 本地读取（Local read）   | 本地 cache 读取本地 cache 数据 |
| 本地写入（Local write）  | 本地 cache 写入本地 cache 数据 |
| 远端读取（Remote read）  | 其他 cache 读取本地 cache 数据 |
| 远端写入（Remote write） | 其他 cache 写入本地 cache 数据 |

* cache 分类：

前提：所有的 cache 共同缓存了主内存中的某一条数据。

| cache分类  | 解释                         |
| ---------- | ---------------------------- |
| 本地 cache | 指当前 cpu 的 cache          |
| 触发 cache | 触发读写事件的 cache         |
| 其他 cache | 指既除了以上两种之外的 cache |

注意：本地的事件触发 本地 cache 和触发 cache 相同。


* MESI状态转换：

![basic_2.png](https://i.loli.net/2020/03/19/Nm2cBGPewr15Szo.png)

* 切换的解释：

![basic_3](![basic_3.png](https://i.loli.net/2020/03/19/loCVtZhgnzqaJX1.png))



#### 2.CPU多级缓存的乱序执行优化

处理器为提高运算速度而做出违背代码原有顺序的优化，使得在多核的情况下，实际结果可能和逻辑运行结果大不相同，



#### 3.**线程和主内存的抽象关系**

![image-20200319104008584.png](https://i.loli.net/2020/03/19/M7IOBiKVlPvCf5x.png)

说明：

每个线程之间**共享变量都存放在主内存**里面，每个线程都有一个私有的本地内存 （工作内存），本地内存是java内存模型中抽象的概念，并不是真实存在的（他涵盖了缓存写缓冲区、寄存器以及其他硬件的优化） 本地内存中存储了以读或者写共享变量的拷贝的一个副本 。
从一个更低的层次来说，线程本地内存，他是cpu缓存，寄存器的一个抽象描述，而JVM的静态内存存储模型，它只是一种对内存模型的物理划分而已，只局限在内存，而且只局限在JVM的内存 。

如果线程 A 和线程 B 要通信，必须经历两个过程： 

- A 将本地内存变量刷新到主内存 

- B 从主内存中读取变量 



#### 4.内存间交互操作

Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。

![image-20200319103431053.png](https://i.loli.net/2020/03/19/NzL2RFw3PApxmJW.png)

- lock（锁定）：作用于主内存的变量，把一个变量标识变为一条线程独占状态
- unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用

- load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入**工作内存的变量副本**中
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受到的值**赋值给工作内存的变量**
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
- write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中

#### **5.同步规则**

- 如果要把一个变量从主内存中赋值到工作内存，就需要按顺序得执行 read 和 load 操作，如果把变量从工作内存中同步回主内存中，就要按顺序得执行 store 和 write 操作，**但 java 内存模型只要求上述操作必须按顺序执行，没有保证必须是连续执行。**

- 不允许 read 和 load、store 和 write 操作之一单独出现。

- 不允许一个线程丢弃他的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。

- 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步到主内存中。

- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。
    即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 load 和 assign 操作。

- 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以同时被一条线程重复执行多次，多次执行lock 后，只有执行相同次数的 unlock 操作，变量才会解锁，lock 和 unlock 必须成对出现。

- **如果一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎中使用这个变量前需要重新执行 load 或assign 操作初始化变量的值**。

- 如果一个变量事先没有被 lock 操作锁定，则不允许他执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。

- 对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。


