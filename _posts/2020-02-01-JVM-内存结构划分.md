---
layout:     post
title:      JVM 内存划分
subtitle:   JVM 内存结构部分一
date:       2020-02-01
author:     GJXAIOU
header-img: img/post-bg-JVM.jpg
catalog: true
tags:
   - JVM
   - 内存结构 
---

##  JVM 内存划分

> jdk 的 1.7 和 1.8 中间有区别
>
> 虚拟内存：将一些磁盘空间当做内存使用；

JVM 在运行 Java 程序的过程中会将其所管理的内存划分为若干个不同的数据区域，JVM 管理的内存包括以下几个运行时数据区域：（下图为 JVM 运行时内存数据区域）

![166786b5cf6d7f95.png](https://i.loli.net/2020/03/08/pYvXMSEr2ufRAtL.png)

| 区域       | 是否线程共享 | 是否会内存溢出 |
| ---------- | ------------ | -------------- |
| 程序计数器 | 否           | 不会           |
| 虚拟机栈   | 否           | 会             |
| 本地方法栈 | 否           | 会             |
| 堆         | 是           | 会             |
| 方法区     | 是           | 会             |

- **虚拟机栈**：每个虚拟机栈都是归属于一个线程的，是线程私有的空间，当一个线程创建的时候，与之对应的虚拟机栈就产生了，线程消亡则对应的虚拟机栈就消失；**生命周期同线程相同**；其描述的是 Java 方法执行的内存模型，每个方法执行的同时都会创建一个栈帧。

    - 虚拟机栈中数据称为：栈帧：**每一个方法执行的时候都会创建一个与该方法有关并且独有的栈帧**（JVM 是基于栈执行的），里面存储操作数栈中数据，局部变量表（就是该线程可以自己访问到的局部变量信息（包括八种基本数据类型（其中 64 位的 long、double 占用两个局部变量空间（Slot））和对象引用（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个-  代表对象的句柄或者其他与此对象相关的位置）））、方法的返回地址（出口，即执行一条字节码指令的地址）、动态连接等，即主要存储与方法执行相关的内容；**每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。** 

    - **通常所说的栈，一般是指虚拟机栈中的局部变量表部分**。**局部变量表所需的内存空间在编译期间完成分配，运行期不会改变**。 

    - 异常：栈的大小可以固定也可以动态扩展，当扩展到无法申请足够的内存，则 OutOfMemoryError。 当栈调用深度大于 JVM 所允许的范围，会抛出 StackOverflowError 的错误，不过这个深度范围不是一个恒定的值

        

- **程序计数器**（Program Counter Register）：**是当前线程所执行的字节码的行号指示器**，描述字节码解释权工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，线程在执行字节码时候，执行完当前字节码之后，指定下一行字节码的位置在哪（因为执行可以顺序也可以跳转）；

    - 是线程所私有的内存空间（或者说是数据结构），针对多线程，本质上是通过线程轮流切换并分配处理器执行时间的方式实现，即在任意一个确定时刻，一个处理器都只会执行一条线程中的指令，因此切换执行下一个线程需要记住上一个线程挂起到什么位置（便于恢复到正确的执行位置），因此**每个线程都有一个独立的程序计数器**，各个线程之间计数器互不影响，独立存储；
    - 如果线程执行的是一个 Java  方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是 Native 方法，则计数器值为空（Undefined）；

- **本地方法栈**（Native Method Stack）：方法上加上 Native 关键字，表示该方法是有 C/C++ 实现，不是 Java 实现的，即主要用于执行本地方法；同样会抛出 `StackOverflowError` 和 `OutOfMemoryError` 异常。

    - 虚拟机栈和本地方法栈区别：前者是为虚拟机执行 Java 方法（即字节码）服务，后者是为虚拟机使用到的 Native 方法服务。
    - 虚拟机规范中对该部分没有强制规范， **Hotspot 虚拟机直接将本地方法栈和虚拟机栈合二为一**。

- **堆**（Heap）：在虚拟机启动时候创建，对所有线程共享，**存放绝大部分的对象实例**（部分会使用栈上分配，标量替换 技术存放在其他位置），==Java 中不能直接使用对象，只能通过引用方式获取该对象然后使用它，引用作为一个变量是在栈中==。

    - **线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）**

    - Java 堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，一般都是可以扩展的；

- **方法区**：==对所有线程共享，存储元信息，包括已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码、类中（Class ）固有的信息==；**在 Hotspot 中 永久代（Permanent Generation）从 JDK 1.8 中已经废弃 ，并且永久代不等于方法区，Hotspot 虚拟机（其他虚拟机不存在永久代概念）==使用永久代来实现方法区，即将 GC 分代收集器拓展到方法区==，使得垃圾收集器可以像管理 Java 堆一样管理该部分内存，省去专门为方法区编写内存管理代码的工作**。

    - 运行时常量池（Runtime Constant Pool）：方法区的一部分，Class 文件中的常量池会存储编译期生成的字面值和符号引用，该部分内容在类加载后进入方法区的运行时常量池中存放，**运行时常量池相比 Class 文件常量池而言具有动态性**，因为 Java 并不要求常量一定只有编译期才能产生即并非只有预置在 Class 文件中常量池部分的内容才可以进入方法区运行时常量池，**运行期间也可以将新的常量池放入池中**，例如：String 类的 intern（） 方法；

- **直接内存**：不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，即不是 JVM 管理的内存，与 Java NIO（New Input/Output） 密切相关，通过使用 Native 函数库直接分配堆外内存，由操作系统进行管理， JVM 通过存储在堆上的 DirectByteBuffer 对象作为该内存的引用来操作直接内存；