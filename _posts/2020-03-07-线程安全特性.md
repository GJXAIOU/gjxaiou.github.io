---
layout:     post
title:      线程安全特性 
subtitle:   Java 并发学习系列博客
date:       2020-03-07
author:     GJXAIOU 
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Java 并发
---



# 线程安全特性

## 一、概念

- **定义**：当多个线程访问某个类时，不管运行环境采用**何种调度方式**或者将这些进程如何交替执行，并且在主调代码中**不需要任何额外的同步或者协同**，这个类都表现出**正确的行为**，那么称这个类是线程安全的。

- 线程安全的三大特性：
    - 原子性: 原子性是指一个操作是**不可中断的，要么全部执行成功要么全部执行失败**。即使在多线程环境下提供了互斥访问，一个操作一旦开始就不能被其他线程干扰或中断。

    - 可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改。

    - 有序性：程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。

>为了性能优化，编译器和处理器会进行指令重排序，由于指令重排序的存在，该观察结果一般杂乱无序。
>Java程序天然的有序性可以总结为：**如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的**。

## 二、具体分析

### （一）原子性

**原子性实现方式**：

* synchronized：不可中断锁，适合竞争不激烈，可读性好。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。

* Lock：可中断锁（使用 Unlock 即可），多样化同步，竞争激烈时能维持常态

* Atomic：竞争激烈时能维持常态，比Lock性能好；**只能同步一个值**，例如可以使用原子类 AutomicInteger 等。

Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。同样 int 等原子性的类型在多线程环境中也会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。

### （二）可见性

**可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。**

**导致共享变量在线程中不可见的原因**:

- 线程交叉执行

- 重排序结合线程交叉执行

- 共享变量更新后的值没有在工作内存与主内存间及时更新

**三种实现可见性的方式：**

- volatile：**通过加入内存屏障和禁止重排序优化来实现，即重排序时不能把后面的指令放到内存屏障之前**

    - 对 volatile 变量写操作时，会在写操作后加入一条 **store 屏障指令**，将本地内存中的共享变量值刷新到主内存

    ![image-20200316193740745.png](https://i.loli.net/2020/03/18/LaCRps3Iv42jHKM.png)

    - 对 volatile 变量读操作时，会在读操作前加入一条 **load 屏障指令**，从主内存中读取共享变量

    ![image-20200316193759330.png](https://i.loli.net/2020/03/18/ydMRX1IW7PA8Dvj.png)

    使用 volatile 修饰变量count，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。

- synchronized：

    - 线程解锁前，必须把共享变量的最新值刷新到主内存

    - 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值
        （注意，加锁和解锁是同一把锁）

- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

### （三）有序性

有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

**保证有序性方式**：

- volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

- 通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

## 三、先行发生原则

**上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。**

- 单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。

- 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

- volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
- 线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。
- 线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。
- 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。
- 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。
- 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。