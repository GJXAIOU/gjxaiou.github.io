---
layout:     post
title:      布隆过滤器
subtitle:   数据结构与算法系列博客
date:       2019-12-02
author:     GJXAIOU 
header-img: img/post-bg-algorithm.jpg
catalog: true
tags:
    - 数据结构与算法
    - 布隆过滤器
---

## 布隆过滤器

### （一）作用

- 一般用于判断某个值是否在集合中，如果在则一定返回 true，但是不在也可能返回 true，**有失误率**。即判断==某样东西一定不存在或者可能存在==。
- 相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的；
- 判断某个元素是否存在可以使用 HashMap，时间复杂度为 O（1），但是存储容量占比高（占用内存高），同时对于本地输入，数据在远程服务器，同时数据集大到无法一次性读进内存构建 HashMap 时候也存在问题。
- ==比较针对黑名单问题和爬虫去重问题==；

### （二）示例

**问题**： 判断 100 亿条占 64 字节的 URL，是否为一个 URL 黑名单集合中元素，在则返回 true，反之返回 false；

**解答**：

- 方案一：使用 HashSet，但是至少需要使用 6400 亿个字节长度（不包括指针等等占用位置），约为 640 G空间。
- 方案二：使用上述提到的哈希分流。
- 方案三：使用布隆过滤器
    布隆过滤器是一个数组，每个元素为 1 个 bit。
    ![输入图片描述](2019-12-02-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.resource/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8_20191227144111.png)

**实现布隆过滤器代码**：

```java
package com.gjxaiou.easy.day05;

/**
 * 使用基本数据结构实现布隆过滤器，如果想减少数组空间，可以使用 Long 类型或者使用矩阵
 * @author GJXIAOU
 * @create 2020/1/14 0014 下午 1:43
 */

public class BloomFilter {
    public static void main(String[] args) {
        // 使用 int 类型，因为一个 int 占 4 位即 32 bit，因此 1000 个 int 数据可以表示 32000bit；
        int[] arr = new int[1000];
        // 想要查询的 30000 位置对应哪一个下标；即将第 30000 位置描黑。
        int index = 30000;
        // 结果对应于上面数组中的 0 ~ 999 中间一个位置（桶）； intIndex = 937
        int intIndex = index / 32;
        // 对应于桶中的具体哪一个 bit 应该被描黑；bitIndex = 16
        int bitIndex = index % 32;
        // 1 << 16,即只有第 16 位为 1，其他均为0，同时 num | (1 << 16) 使得 num 的第 16 号位置变为 1，
        arr[intIndex] = (arr[intIndex] | (1 << bitIndex));
    }
}
```

**实现过程**
取其中一个 URL 分别经过 K 个相互独立的哈希函数（hash1，hash2，hash3，。。。hashk），分别得到哈希值 code1，code2，code3，。。。codeK，然后对所有的哈希值 %m，得到 0 ~ m - 1 之间的某个值，将这个值的位置描黑（如果该位置已经描黑，则继续描黑）。将所有的 URL 都按照此步骤走一遍，如果某个 URL 对应的 K 个数组中位置都是描黑的，则该 URL 在黑名单中，如果有一个不为黑则不在 URL 中。

### （三）布隆过滤器添加元素

-   将要添加的元素给 k 个哈希函数，得到对应于位数组上的 k 个位置
-   将这 k 个位置设为 1

### （四）布隆过滤器查询元素

-   将要查询的元素给 k 个哈希函数，得到对应于位数组上的 k 个位置
-   如果 k 个位置有一个为 0，则肯定不在集合中
-   如果 k 个位置全部为 1，则可能在集合中

**示例**：
布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：
![输入图片描述](2019-12-02-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.resource/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BB%93%E6%9E%84_20191227160326.jpg)


如果我们要映射一个值到布隆过滤器中，我们需要使用**多个不同的哈希函数**生成**多个哈希值，**并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：

![](2019-12-02-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.resource/v2-a0ee721daf43f29dd42b7d441b79d227_hd.jpg)

Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：

![](2019-12-02-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.resource/v2-c0c20d8e06308aae1578c16afdea3b6a_hd.jpg)

值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，**说明没有任何一个值映射到这个 bit 位上**，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu”  **存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。**

这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。

### （五）不支持删除

不支持 delete 操作，只支持 add 和 isExit 操作，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。

如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。

### （六）如何选择哈希函数个数和布隆过滤器长度

很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。

另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。

![](2019-12-02-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.resource/v2-05d4a17ec47911d9ff0e72dc788d5573_hd.jpg)

k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率

如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：

$$m = - \frac{nln^p}{(ln^2)^2}$$

$$k = \frac{m}{n}ln^2$$

如何推导这个公式这里只是提一句，因为对于使用来说并没有太大的意义。k 次哈希函数某一 bit 位未被置为 1 的概率为：$$(1-\frac{1}{m})^{k}$$

插入n个元素后依旧为 0 的概率和为 1 的概率分别是：$$(1 - \frac{1}{m})^{nk} 和 1-(1 - \frac{1}{m})^{nk}$$

标明某个元素是否在集合中所需的 k 个位置都按照如上的方法设置为 1，但是该方法可能会使算法错误的认为某一原本不在集合中的元素却被检测为在该集合中（False Positives），该概率由以下公式确定

$$[1-(1 - \frac{1}{m})^{nk}]^k ≈ (1 - e^{\frac{-kn}{m}})^k$$



## 四、最佳实践

常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。

另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。

**大Value拆分**

Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。

拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。

**优化**

- 所需数组的长度和 URL 的数目有关，和需求的失误率有关，和每条 URL 的长度（所含字节数）无关；
- 数组长度计算公式：$$m = - \frac{n * (ln^p)}{(ln^2)^2}$$，其中 n表示样本量， p 为预期失误率；
    此题中： n = 100亿，p = 0.0001，则 m = 131571428572 bit ≈ 16G。
- 需要哈希函数的个数：$$ K = In^{2} * \frac{m}{n} = 0.7 * \frac{m}{n}$$ ，这里约等于 13，如果计算的值为小数，需要进行向上取整；
- 真实失误率：$$ (1 - e^{-\frac{n * k}{m}})^k $$ ，这里计算的值约为：十万分之六，低于要求的失误率。

