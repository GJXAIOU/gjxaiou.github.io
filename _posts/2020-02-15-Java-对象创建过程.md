---
layout:     post
title:      Java 对象创建过程
subtitle:   JVM 内存模型系列二
date:       2020-02-15
author:     GJXAIOU 
header-img: img/post-bg-debug.png
catalog: true
tags:
    - JVM
    - JVM 内存模型
---



## Java 对象创建过程

> 注：这里对象指普通 Java 对象，不包括数组和 Class 对象

### （一）创建对象的方式

- 使用 new 关键字
- 使用 clone
- 通过反射
- 通过反序列化

### （二）使用 new 关键字创建对象步骤

* **步骤一：在堆内存中创建出对象的实例**

    当虚拟机遇到一条 new 指令时候，首先虚拟机会检查该指令的参数**能否在常量池中定位到一个类的符号引用**，然后检查这个符号引用所代表的类是不是被正确的加载、连接、初始化，如果没有首先进行类加载过程。

    **当上述过程完成之后，虚拟机开始为新生对象分配内存（实际分配的内存空间在对象加载完成之后就确定了）**，为对象分配内存的任务相当于将一块确定大小的内存从 Java 堆中划分出来；

    在堆中为对象分配内存分为两种情况（因为堆内存空间分为已经被占用和未被占用两部分）

    - **情况一（指针碰撞 Bump the Pointer）**：针对如果占用和未占用分别是两块连续空间，中间存放一个指针作为分界点的指示器来分割堆空间。如果在未被占用的空间中为对象分配了一段的内存空间，则原来指向未被占用空间位置的指针发生偏移，指向下一个未被占用的空间位置（指针挪动的距离等价于分配的内存），这样对象就创建完成了；
    - **情况二（空闲列表 Free List）**：针对已使用和未使用的空间不连续，相互交织。虚拟机会记录已被使用和未被使用的地址列表，以及未被使用的内存地址大小，如果需要为对象分配内存空间，则需要在未被使用的地址列表中选择一块可以容纳该对象的内存空间放置对象，然后修改列表中的记录；

    

    **补充问题**：

    - 为什么堆不确定是否平整：取决于堆所采用的垃圾收集器是否带有压缩整理功能；

    - 针对并发情况下频繁创建对象可能带来的线程不安全问题（分配了内存但是指针没来得及修改，其他对象同时使用了原来的指针进行分配内存）：

        - 方法一：对分配内存空间的动作进行同步处理（虚拟机中采用 CAS 加上失败重试保证更新操作的原子性）；

        - 方法二：将内存分配的动作按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块内存称为本地线程分配缓存（TLAB），哪个线程要分配内存时就在哪个线程的 TLAB 上进行分配，只有自己的 TLAB 用完并分配新的 TLAB 时候才需要进行同步锁定，可以使用 `-XX:+/-UseTLAB`参数设定。

            

* **步骤二：为对象的实例成员变量赋初值**（对于静态变量在加载阶段就进行了赋初值）

    因为虚拟机在内存分配完成之后就会将分配到的内存空间都初始化为零值（不包括对象头）（若使用 TLAB，在分配 TLAB 时就执行该步骤），保证对象的实例字段可以在不赋初值情况下就可以使用。

    虚拟机对对象进行必要的设置，如该对象为哪个类的实例、怎么找到类的元数据，对象的 Hash 码等，这些信息都存放在**对象的对象头**中，可以进行不同设置。至此对于虚拟机来说一个对象已经产生了，但是对于 Java 程序而言对象创建才刚刚开始，还需要执行 `<init>`方法，同时对字段进行赋值。

    

* **步骤三：将对象的引用返回**



**示例**：

下面的 new 步骤生成了两部分的内存区域：

- object 这个引用变量，因为是方法内的变量，放到 JVM Stack里面
- 真正 Object class的实例对象，放到 Heap 里面。

==**上述的 new 语句一共消耗 12 个 bytes, JVM 规定引用占 4  个 bytes (在 JVM Stack)， 而空对象是 8 个 bytes (在Heap)方法结束后，对应 Stack 中的变量马上回收，但是 Heap 中的对象要等到 GC 来回收**==。

```java
public void method() {
    Object object = new Object();
}
```



### （三）对象在内存中的布局（即对象包含的信息）

> 包含对象头、实例数据和对齐填充（后两者只存在于数组对象中）

* 对象头（Header）：例如对象的 Hash 码以及分代信息
    * 一部分称为：**标记词**（Mark Word）用于存储自身的运行时的数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID，根据虚拟机位数不同占 32 / 64 bit，该部分数据结构不固定，会根据对象的状态复用自己的存储空间。
    * 另一部分为：**类型指针**，即对象指向它的类元数据的指针（**虚拟机通过该指针来确定这个对象是哪个类的实例**），但是不是所有的虚拟机实现都必须在对象数据上保留类型指针；

  * 另一部分：**只有数组对象有**，用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数据的元数据中却无法确定数组的大小。

    * 实例数据（Instance Data）：即对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容（无论是从父类继承或者子类中定义的）。这里信息存储的顺序受虚拟机分配策略参数和字段在 Java 源码中定义顺序的影响；Hotspot 虚拟机中默认的分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans，oops(Ordinary Object Pointers)，其次父类中定义的变量在子类之前；
    * 对齐填充（Padding）（非必须）：起到占位符作用，因为 Hotspot 中自动内存管理系统要求对象起始地址必须是 8 字节的整倍数（即对象的大小必须是 8 字节的整数倍）。

    

### （四）对象的访问定位（引用访问对象的方式）

**Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象，具体的引用访问对象的方式共有两种：通过句柄或者直接指针**。
     

* **方式一：使用句柄的方式**

    - 首先在**堆**中划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址。**句柄分为两部分，一部分为该对象实例真正的指针，指向真正的对象实例数据信息，第二部分为类型数据各自的具体地址信息，元数据信息放置在方法区。**
    - 优势：reference 中存储的是稳定的句柄地址，当对象移动（如垃圾回收时候）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

    ![通过句柄方式访问对象](https://github.com/GJXAIOU/gjxaiou.github.io/tree/master/img/2020-02-15-Java-对象创建过程.resource/955ac97ce62d2deb57356f1aee43f33a.jpeg)

     * **方式二：使用直接指针的方式**（Hotspot 使用方式）

        - Java 堆对象中放置访问类型数据的相关信息，reference 中存储的是对象地址。

        - 优势：速度更快，节省一次指针定位的时间开销（并且对象的访问在 Java 中非常频繁）。

        ![通过直接指针方式访问对象](https://github.com/GJXAIOU/gjxaiou.github.io/tree/master/img/2020-02-15-Java-对象创建过程.resource/ee322420543cd38485ba6e1ae665ac82.jpeg)