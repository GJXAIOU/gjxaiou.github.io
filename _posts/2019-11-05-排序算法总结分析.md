---
layout:     post
title:      排序算法总结
subtitle:   数据结构与算法系列博客
date:       2019-11-05
author:     GJXAIOU 
header-img: img/post-bg-debug.png
catalog: true
tags:
    - 数据结构与算法
    - 排序算法
---

## 排序算法总结分析

### （一）冒泡排序

两两比较，将较大的一个一个向上冒，**每次只能排好一个数**；

时间复杂度：$O(N^{2})$
空间复杂度：$O(1)$

```java
import java.util.Arrays;

public class BubbleSort {

    public static void bubbleSort(int[] sourceArray) {
        if (sourceArray == null || sourceArray.length < 2) {
            return;
        }
        // end 刚开始在 length-1,但是得大于零，每排完一圈就确定一个最大值，然后值减一；
        for (int end = sourceArray.length - 1; end > 0; end--) {
            for (int start = 0; start < end; start++) {
                if (sourceArray[start] > sourceArray[start + 1]) {
                    swap(sourceArray, start, start + 1);
                }
            }
        }
    }

    public static void swap(int[] sourceArray, int left, int right) {
        sourceArray[left] = sourceArray[left] ^ sourceArray[right];
        sourceArray[right] = sourceArray[left] ^ sourceArray[right];
        sourceArray[left] = sourceArray[left] ^ sourceArray[right];
    }
}    
```



### （二）选择排序

首先从 1 ~ N-1 上选择最小的数和 0 位置上互换，然后才能够 2 ~ N-1 上选择最小的数和 1 位置上互换.....，**每次只能排好一个数**；

时间复杂度：$O(N^{2})$
空间复杂度：$O(1)$

```java
package sort.com.gjxaiou;

import java.util.Arrays;

public class SelectionSort {

    public static void selectionSort(int[] sourceArray) {
        if (sourceArray == null || sourceArray.length < 2) {
            return;
        }
        for (int start = 0; start < sourceArray.length - 1; start++) {
            int minIndex = start;
            // 从 i + 1 位置到最后的最小的数下标
            for (int cur = start + 1; cur < sourceArray.length; cur++) {
                minIndex = sourceArray[cur] < sourceArray[minIndex] ? cur : minIndex;
            }
            swap(sourceArray, start, minIndex);
        }
    }

    public static void swap(int[] sourceArray, int left, int right) {
        int tmp = sourceArray[left];
        sourceArray[left] = sourceArray[right];
        sourceArray[right] = tmp;
    }
}
```

**注意：**
上面的交换程序可以改为：

```java
 public static void swap(int[] sourceArray, int left, int right) {
        if (left == right){
            return;
        }
        sourceArray[left] = sourceArray[left] ^ sourceArray[right];
        sourceArray[right] = sourceArray[left] ^ sourceArray[right];
        sourceArray[left] = sourceArray[left] ^ sourceArray[right];
    }
```

因为如果之前 minIndex 没有改变，则 start 与 minIndex 是相等的，在进行swap()的时候，`arr[left] = arr[left] ^ arr[right];`相当于对两个相同的数做异或运算，结果是0。swap函数出现错误。可以在swap函数加上`if(left==right)return;`来解决。

交换数组中的两个数，一个数自己与自己异或结果为0；一个数与0异或，结果还是自己。



### （三）插入排序

首先默认第一个数（0）是排好序的，然后拿第二个数和第一个数比较，如果比第一个数小，就互换，反之不动，这样 0~1 位置上是排好序的；然后拿第三个数和第二个数比较，比他小就互换，如果更换之后再次和第一个数比较，看是否需要互换，最终 0~2 位置上是排好序的.......

最好的情况是原来就有序：$O(N)$，最差的情况是原来就是倒序的：$O(N^{2})$；因此最终的时间复杂度为：$O(N^{2})$，空间复杂度：$O(1)$；

```java
import java.util.Arrays;

public class InsertionSort {

    public static void insertionSort(int[] sourceArray) {
        if (sourceArray == null || sourceArray.length < 2) {
            return;
        }
        for (int end = 1; end < sourceArray.length; end++) {
            for (int cur = end - 1; cur >= 0 && sourceArray[cur] > sourceArray[cur + 1]; cur--) {
                swap(sourceArray, cur, cur + 1);
            }
        }
    }

    public static void swap(int[] sourceArray, int left, int right) {
        sourceArray[left] = sourceArray[left] ^ sourceArray[right];
        sourceArray[right] = sourceArray[left] ^ sourceArray[right];
        sourceArray[left] = sourceArray[left] ^ sourceArray[right];
    }
}
```



### （四）归并排序

归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题 **分**(divide) 成一些小的问题然后递归求解，而 **治(conquer)** 的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

流程：首先将数组对半分为两个部分，然后分别对左右两边进行排序；最后对整体进行外排；
重点关注：最后整体的外排

![1024555-20161218163120151-452283750.png](https://i.loli.net/2020/03/12/iqvTwtclkfjCsA9.png)

![1024555-20161218194508761-468169540.png](https://i.loli.net/2020/03/12/QlacP7KLVHIyv3d.png)

```java
package com.gjxaiou.easy.day01;

import java.util.Arrays;

/**
 * 归并排序
 * 将整个数组分为两个部分，然后分别排序之后再使用外排进行合并
 */
public class MergeSort {

    public static void mergeSort(int[] sourceArray) {
        if (sourceArray == null || sourceArray.length < 2) {
            return;
        }
        mergeSort(sourceArray, 0, sourceArray.length - 1);
    }

    public static void mergeSort(int[] sourceArray, int left, int right) {
        if (left == right) {
            return;
        }
        // 求数组中间点，将数组划分为两部分
        int mid = left + ((right - left) >> 1);
        mergeSort(sourceArray, left, mid);
        mergeSort(sourceArray, mid + 1, right);
        merge(sourceArray, left, mid, right);
    }

    public static void merge(int[] sourceArray, int left, int mid, int right) {
        // 准备一个和原数组等长的辅助数组；
        int[] help = new int[right - left + 1];
        int i = 0;
        int startLeft = left;
        int startRight = mid + 1;
        while (startLeft <= mid && startRight <= right) {
            help[i++] = sourceArray[startLeft] < sourceArray[startRight] ? sourceArray[startLeft++] : sourceArray[startRight++];
        }
        // 上面的 while 循环会将一个数组中元素全部挪到 help 数组中，而另个数组还会剩余最后几个元素
        // 将剩余的一个数组中剩余的元素全部移到 help 数组中，这两个 while 只会执行一个
        while (startLeft <= mid) {
            help[i++] = sourceArray[startLeft++];
        }
        while (startRight <= right) {
            help[i++] = sourceArray[startRight++];
        }
        for (i = 0; i < help.length; i++) {
            sourceArray[left + i] = help[i];
        }
    }
}
```

**示例：** 原来数组元素为：3，6，4，5，2，8；首先划分为：Left:[3,6,4]和 right:[5,2,8]；然后将他们分别排序为：Left:[3,4,6] 和 Right:[2,5,8]，然后左右各取指针 a,b，同时准备一个辅助数组，长度和原数组长度相同；然后比较 a,b 指向元素的大小，哪一个小哪一个就放进数组，同时下标 + 1，然后再次比较，直到某一方全部放入数组，则另一方剩余的全部放入数组，最后将该数组拷贝回原来数组；
因为一共 N 的样本，分为两个一样的部分，每部分的时间复杂度为 ：$T(\frac{\mathrm{N}}{2})$，每一部分进行比较等操作为：$O(N)$，因此时间复杂度为：$T(N) = 2* T({\frac{N}{2}}) + O(N)$，根据 master 公式结果为：$O(N * \log_{2}^{N})$ 
空间复杂度：$O(N)$



### （五）快速排序

#### （一）经典快排

首先以数组最后一个数值为基准，将小于等于该数值的全部放在数组前半部分，大于该数值的全部放在数组的后半部分，然后前半部分和后半部分分别以该部分最后一个元素为基准重复以上步骤；

**改进**：使用荷兰国旗思想
首先还是选取数组最后一个值为基准，但是遍历判断的时候最后一个值不再进行判断，即只有 L ~ R - 1 的值与基准进行比较，同时区域划分为三个区域：小于基准、等于基准、大于基准；然后将小于基准和大于基准部分进行再次取最后一个数，同上进行比较.....最后全部比较结束之后，将最后一个基准值放在大于该基准的范围的前一个位置；


特点：

- 经典快排和数据的状态有关：
    - 当小于最后一个数值的元素远大于大于最后一个数组的元素个数时候，或者反之情况，时间复杂度都是：$O({N}^{2})$
    - 如果数据状态较好，即大于和小于差不多的情况下，时间复杂度为：$T(N) = 2T(\frac{N}{2}) + O(N) = O(N * log_{2}^{N})$

经典快排的空间复杂度为：$O(N)$

#### （二）随机快速排序

通过随机选一个数和最后一个数进行互换，使得每次划分标准都在改变；
根据随机性，随机快速排序的时间复杂度是：$O(N * \log_{2}^{N})$，同时需要空间复杂度为：$O(\log_{2}^{N})$，这里的额外空间主要用于记录每次划分区域的断点；

```java
package com.gjxaiou.easy.day01;  
  
/**  
 * @author GJXAIOU  
 * @create 2019-10-04-20:08  
 * <p>  
 * 随机快排  
  */  
  
import java.util.Arrays;  
  
public class QuickSort {  
    /**  
 * 首先调用该方法，可以设置排序的区间，默认为 0 ~ length-1；  
  *  
 * @param sourceArray：需要排序的数组  
  */  
  public static void quickSort(int[] sourceArray) {  
        if (sourceArray == null || sourceArray.length < 2) {  
            return;  
        }  
        quickSort(sourceArray, 0, sourceArray.length - 1);  
    }  
  
    /**  
 * @param sourceArray：需要排序的数组  
  * @param left：排序数组左边界，一般为：0  
 * @param right：排序数组右边界，一般为：length - 1;  
 * less：小于参照元素区域的最右边边界：less = p[0] - 1;  
 * more：大于参照元素区域的最左边边界：more = p[1] + 1;  
 * p[0]：等于参照元素区域的最左边边界；  
  * p[1]：等于参数元素区域的最右边边界；  
  * 小于参照元素区域：[Left ~ less];  
 * 等于参照元素区域：[p[0] ~ p[1]]；  
  * 大于参照元素区域：[more ~ right]；  
  */  
  public static void quickSort(int[] sourceArray, int left, int right) {  
        if (left < right) {  
            swap(sourceArray, left + (int) (Math.random() * (right - left + 1)), right);  
            // p 数组中： p[0] 表示等于区域的左边界，p[1] 表示等于区域的右边界，  
  // 左边区域：L ~ p[0] - 1;右边区域： p[1] + 1 ~ R;  int[] p = partition(sourceArray, left, right);  
            quickSort(sourceArray, left, p[0] - 1);  
            quickSort(sourceArray, p[1] + 1, right);  
        }  
    }  
  
    public static int[] partition(int[] sourceArray, int left, int right) {  
        int less = left - 1;  
        int more = right;  
        while (left < more) {  
            // 以数组最后一个元素为标准，将整个数组划分为 小于、等于、大于 三个部分  
  if (sourceArray[left] < sourceArray[right]) {  
                swap(sourceArray, ++less, left++);  
            } else if (sourceArray[left] > sourceArray[right]) {  
                swap(sourceArray, --more, left);  
            } else {  
                left++;  
            }  
        }  
        swap(sourceArray, more, right);  
        return new int[]{less + 1, more};  
    }  
  
    public static void swap(int[] sourceArray, int left, int right) {  
        int tmp = sourceArray[left];  
        sourceArray[left] = sourceArray[right];  
        sourceArray[right] = tmp;  
    }  
  
  
    public static void main(String[] args) {  
        int[] arr = {43, -31, 10, -38, -42, -2, 22, 29, 30, 15, -60, -50, -13, 26, 3, 22, 27, 24, 18, 18, 42, -40, 22, 8, 33, -52, -70, -55, 31, 42, 82, 19, -8, 8, 41, -35, 59, 65, -23, 3, -34, 65};  
        System.out.println("原数组为：");  
        for (int i = 0; i < arr.length; i++) {  
            System.out.print(arr[i] + "  ");  
        }  
  
        quickSort(arr);  
        System.out.println("\n排序后数组为：");  
        for (int i = 0; i < arr.length; i++) {  
            System.out.print(arr[i] + "  ");  
        }  
    }  
  
}
```

程序运行结果：

```java
原数组为：
43  -31  10  -38  -42  -2  22  29  30  15  -60  -50  -13  26  3  22  27  24  18  18  42  -40  22  8  33  -52  -70  -55  31  42  82  19  -8  8  41  -35  59  65  -23  3  -34  65  
排序后数组为：
-70  -60  -55  -52  -50  -42  -40  -38  -35  -34  -31  -23  -13  -8  -2  3  3  8  8  10  15  18  18  19  22  22  22  24  26  27  29  30  31  33  41  42  42  43  59  65  65  82 
```



### （六）堆排序

#### （一）堆

- **==堆是一个完全二叉树==**，可以采用数组进行实现；
- ==对于完全二叉树，结点 i 的左孩子序号为：2i + 1；右孩子序号为：2i + 2；父结点的序号为：$\frac{i - 1}{2}$==。

- 分类：
    - 大根堆：每棵树（包括任意一棵子树）的最大值都是其头部（父结点）；
    - 小根堆：每棵树（包括任意一棵子树）的最小值都是其头部（父结点）；

**完全二叉树**：对一棵具有 n 个节点的二叉树按照层序进行编号，如果编号 i （1<=i<=n）的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同；
**满二叉树**：所有的分支结点都存在左子树和右子树，且所有的叶子都在同一层；

#### （二）数组转换为大根堆

**举个栗子** ：以数组 `[2,1,3,6,0,4]` 为例
首先取出第 0 号元素 2 作为头结点，然后取出第 1个元素 1，该元素的父结点为：$\frac{1 - 1}{1} = 0$，所以和 0 位置元素相比，结果该值 1比 2 小，放在左孩子位置，数组元素为：[2,1]；然后取出第 2 个元素 3，计算该元素的父结点：$\frac{2 - 1}{2} = 0$，则与 0 位置元素 2 进行比较，发现 3 比较大，则在数组中将 3 和 2 两个元素互换，则数组变为：[3,1,2]；然后取出第 3 个元素 6，计算父结点下标为：$\frac{3 - 1}{2} = 1$，则与 1 位置的元素 1 进行比较，发现 6 比较大，则将元素 1 和元素 6 互换，得到[3,6,2,1]，然后再比较元素 6 和其父结点：$\frac{1 - 1}{2} = 0$，比较得出 6 比 3 大，然后再换，最后得到数组为：[6,3,2,1]，剩下元素依次类推......

![image-20200220134617870.png](https://i.loli.net/2020/03/12/4RQSIuixBmK7O8F.png)

**每加入一个节点其最多比较的次数和已经形成的二叉树高度有关**（因为每次只和其父结点比较），因此最多时间复杂度为：$O(log_{2}^{N})$，所有整个转换过程时间复杂度为：$log_{2}^{1} + log_{2}^{2} + ..... + log_{2}^{N} = O(N)$

**示例题目**
吐泡泡：一个 XXX 会不停的吐出数字，求任意时刻的已经吐出的所有元素的中位数；

**解答：**
这里需要同时使用大根堆和小根堆，大根堆中存放着较小的 $\frac{N}{2}$个元素，小根堆中存放较大的  $\frac{N}{2}$个元素；

这里以：5 4 6 7 为例
首先将 5 **放入大根堆**，计算大根堆和小根堆的 Heapsize，差值为 1,不动， 然后因为 4 **小于等于大根堆的堆顶，因此放入大根堆**，再次计算 HeapSize，插值 > 1，然后将大根堆的堆顶放在小根堆，接着将大根堆剩余的调整为大根堆，然后元素 6 大于大根堆现在堆顶 4，因此放入小根堆；现在大根堆为 4，小根堆为 5,6；插值为 1，然后放入元素 7，同样大于大根堆堆顶，放入小根堆，然后插值> 1，将**小根堆的堆顶放入大根堆末尾**，小根堆重新排为：6,7；大根堆重新排为：5,4；中位数就是两个堆顶的平均值；


#### （三）堆排序

首先将数组变成大根堆；
然后将堆中最后一个和堆顶进行交换，堆大小减一，则最后一个不动了，然后将剩下的前面进行 Heapify 调整；
然后再将堆的最后一个和堆顶进行交换，同上.....;

```java
package sort.com.gjxaiou.easy.day01;

/**
 * @author GJXAIOU
 * @create 2019-10-04-20:08
 */
import java.util.Arrays;

public class HeapSort {

    public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 首先将数组转化为大根堆；0 到  i 之间形成大根堆
        for (int i = 0; i < arr.length; i++) {
            heapInsert(arr, i);
        }

        // 不断将堆顶的元素和最后一个元素交换然后进行 heapify 过程
        int size = arr.length;
        swap(arr, 0, --size);
        while (size > 0) {
            heapify(arr, 0, size);
            swap(arr, 0, --size);
        }
    }

    public static void heapInsert(int[] arr, int index) {
        // 如果插入的新节点值大于其父结点大小
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    /**
     * size - 1 到 length - 1 位置上已经拍好
     * @param arr：要排序的数组
     * @param index：哪个节点位置上元素发生了变化，传入的初始值一直为0
     * @param size：还没有排好序的数组长度
     */
    public static void heapify(int[] arr, int index, int size) {
        // size 表示当前堆上节点数
        int left = index * 2 + 1;
        // 越界表示已经是叶子结点了
        while (left < size) {
            int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest;
            left = index * 2 + 1;
        }
    }

    public static void swap(int[] arr, int left, int right) {
        int tmp = arr[left];
        arr[left] = arr[right];
        arr[right] = tmp;
    }
}    
```

**概念：**

- HeapInsert：将新的节点加入堆中同时按照堆的结构进行向上调整的过程；
- HeapSize：堆的大小；对应数组中就是 0-i 位置;
- Heapify：假设堆中（数组中）某个值发生了变化，让其整体再次调整为大根堆（或小根堆）原来的样子的过程；
    首先找到变化的值的两个孩子，然后找到其中较大的一个与之交换，如果有交换，在新的位置上再次找现在的两个孩子进行比较，然后交换，一直到没有交换为止；
- 堆减小的过程：以大根堆为例：首先将堆顶元素和堆的最后一个元素位置互换，这样原来堆顶的元素就放在了数组的最后，然后将堆的 Heapsize - 1，这样最后一个元素就应为超过了现在的 HeapSize 而越界，从而失效；然后将剩余的 0 ~ i - 1 位置的按照 Heapify 重新进行调整（因为堆顶的元素值发生了变化）为原来的堆结构；


### （七）排序算法的稳定性

首先总结现有排序算法稳定性

| 算法名称 | 时间复杂度           | 算法种类   | 是否稳定             | 原因                                                         |
| -------- | -------------------- | ---------- | -------------------- | ------------------------------------------------------------ |
| 冒泡排序 | $O({N}^{2})$         | 基于比较   | 稳定                 | 在冒泡的时候，如果遇到前后相同的值两者不交换即可，只有前者比后者大才交换； |
| 插入排序 | $O({N}^{2})$         | 基于比较   | 稳定                 | 同样在比较的时候，相同的值不交换即可；                       |
| 选择排序 | $O({N}^{2})$         | 基于比较   | 不稳定               | 因为如果后面有小于前面的，就和前面的互换，如果有几个相同数，则相当于和最前面的数进行互换，这样顺序就乱了； |
| 归并排序 | $O(N * log_{2}^{N})$ | 基于比较   | 稳定                 | 以为归并之前是左右两个数组，左边数组在原数组中就是在左边，右边数组原来就是右边，这样只需要如果左右两个数组中有相同的数字，则只需要先拷贝左边数组值，然后拷贝右边数组中值即可； |
| 快速排序 | $O(N * log_{2}^{N})$ | 基于比较   | 不稳定（也可以稳定） | 因为 partition 过程就是交换，肯定是无序的；                  |
| 堆排序   | $O(N * log_{2}^{N})$ | 基于比较   | 不稳定               | 因为在形成大根堆的时候，叶子结点与根节点进行交换的时候就会序号乱，例如：2,2,3；当放入 3 的时候，两个 2 的顺序就改变了； |
| 桶排序   | $O(N)$               | 非基于比较 | 稳定                 |                                                              |
| 基数排序 | $O(N)$               | 非基于比较 | 稳定                 |                                                              |
| 计数排序 | $O(N)$               | 非基于比较 | 稳定                 |                                                              |


**排序问题补充：**

- 归并排序的空间复杂度可以变成 O(1)，可以采用 “归并排序 内部缓存法”实现，但是仅仅要求了解即可；
- 快速排序可以做到稳定性，采用“01 stable sort”；
- 荷兰国旗问题不可能稳定，因为明显存在交换；
    问题：将一个数组的奇数放在数组左边，偶数放在数组右边，并且要求原始的相对次序不变，时间复杂度要求：O(N)，空间复杂度要求：O(1)；
    **解析：**   因为每一个数不是奇数就是偶数，因此也是可以抽象为一个 0 1 问题，相当于把 0 类（例如 < 0.5 的，这里 0.5 是随便取，就是为了区分）的放在左边，把大于 0.5 的放在右边，即 1 类 ；且保证原来的相对顺序不变，抽象就是快排的 partition 过程保证稳定；因为 partition 过程就是将一个数组分为 <= 和 > 两个部分，也是 0  1 过程，如果上述满足就可以实现快排稳定；只能采用 01 stable sort 解决；


## （八）非基于比较的排序

#### （一）桶排序

桶排序仅仅是一种概念，整体思想是首先记录数据各状况出现的词频，然后根据词频进行还原从而达到排序目的；
它的具体实现有：计数排序、基数排序；


#### （二）计数排序

**有多少个元素就需要多少个桶；**
示例：有一个元素值范围为：0 ~ N 的数组，将其排序；
步骤：首先准备一个长度为 N + 1 (数组最大值 + 1 )的辅助数组；辅助数组下标分别为：0 ~ N；
然后遍历原数组，有一个 X 值（大小位于 0~N 之间），就在辅助数组下标为 X 的对应元素值 + 1；一直遍历结束；
最后将辅助数组中各个下标对应的元素值还原，示例：辅助数组为：`[1,2,0,2]`就相当于有 1 个 0,2 个 1,0 个 3,2 个 4，因此结果为：`[0,1,1,4,4]`；

```java
package sort.com.gjxaiou.easy.day01;

import java.util.Arrays;

/**
 * 这里是使用计数排序实现桶排序思想
 */
public class BucketSort {
	private static final int WITHOUT_SORT_LENGTH = 2;
	public static void bucketSort(int[] arr) {
		if (arr == null || arr.length < WITHOUT_SORT_LENGTH) {
			return;
		}
		// 首先找到要排序数组中的最大值
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(max, arr[i]);
		}
		// 新建 max + 1 个桶，然后遍历原数组，数组中元素值为X，则 X号桶中值 + 1；
		int[] bucket = new int[max + 1];
		for (int i = 0; i < arr.length; i++) {
			bucket[arr[i]]++;
		}
		// 遍历将 bucket 中按照个数进行还原
		int i = 0;
		for (int j = 0; j < bucket.length; j++) {
			while (bucket[j]-- > 0) {
				arr[i++] = j;
			}
		}
	}
}	
```


#### （三）基数排序

**补充示例：** 给定一个数组，求如果排序之后相邻两个元素的最大差值，要求时间复杂度为 O(N)，且不能用非基于比较的排序；
**解答：**

- 思想：借用桶的思想，但是不使用桶排序；
- 思路：
    - 准备桶，原数组中有 N 个元素，因此准备 N+1 个桶；
    - 遍历原数组，找到原数组中的最小值和最大值，分别放在第 0 号桶和第 N 号桶中；如果最大值等于最小值，直接返回 0 结束；
    - 将新数组（桶）的 0 ~ N 部分等分为 N+ 1 份，原数组中值属于哪一个部分就放在哪一个桶中；示例：如果原数组一共 9 个数，则准备 10 个桶，且第一个桶中放的是数组最小值 0（假定），最后一个桶放的是最大值 99（假定），则将 0 ~ 99 等分为 10 份，则原数组中出现 0 ~ 9 直接的数放在 0 号桶，出现 10 ~ 19 之间的数放在 1 号桶。。。；
    - 每个桶只保留三个值：一个 Boolean 值，用于判断该桶中是否有元素，一个 min，表示桶中的最小值，一个 max ，表示桶中的最大值；因此如果元素 X 进入 7 号桶，如果 7 号桶之前没有元素，则首先将 Boolean 值置为 true，然后 min = x，max = x；当又一个元素进入 7 号桶的时候，比较桶内元素的值，更新最大值和最小值，其他值扔掉；
    - 最后遍历所有的桶，如果遇到空桶，跳到下一个进行判断，如果是非空桶，找到其左边最近的非空桶，将后一个非空的 min - 前一个非空的 max，插值进行保存，然后比较所有的插值，取最大的就是最大插值，

- 原理：因为 0 号桶非空，N 号桶非空，但是只有 N 个数，因此**中间至少有一个桶是空的**，同时任何两个相邻的数可以来自于同一个桶，也可能来自于不同的桶；
    - 为什么要设置一个空桶：因为至少有一个桶为空，则距离空桶左右最近的两个非空桶：左非空 min .... 左非空 max 。。。空桶 。。。右非空 min....右非空 max，则右非空 min - 左非空 max 的插值一定大于桶内插值，因为其值至少是一个桶的长度，而同一个桶内元素之间的插值是不会大于桶长的， 为了证明：**最大的插值一定不会来自于同一个桶**。**但是空桶仅仅是用于否定最终答案不是在同一个桶中，但是不是答案一定就是在空桶的两边；**示例：非空：13,19；空；非空：30，39；非空：59,63；不是空桶左右俩个的插值最大；

```java
package sort.com.gjxaiou.easy.day01;

import java.util.Arrays;

public class MaxGap {
	private static final int WITHOUT_SORT_LENGTH = 2;
	public static int maxGap(int[] nums) {
		if (nums == null || nums.length < WITHOUT_SORT_LENGTH) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		// 找到数组中的最大值和最小值
		for (int i = 0; i < len; i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if (min == max) {
			return 0;
		}
		// 下面三个数组是描述 len + 1 个桶中每个桶的三个必备信息
		boolean[] hasNum = new boolean[len + 1];
		int[] maxs = new int[len + 1];
		int[] mins = new int[len + 1];
		int bid = 0;
		for (int i = 0; i < len; i++) {
		    // 确定该数去第几号桶
			bid = bucket(nums[i], len, min, max);
			// 该桶中的三个信息进行更新
			mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
			maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
			hasNum[bid] = true;
		}
		// 找到每一个非空桶和离他最近的非空桶的插值：用当前min - 前一个max；
		int res = 0;
		int lastMax = maxs[0];
		int i = 1;
		for (; i <= len; i++) {
			if (hasNum[i]) {
				res = Math.max(res, mins[i] - lastMax);
				lastMax = maxs[i];
			}
		}
		return res;
	}

	public static int bucket(long num, long len, long min, long max) {
		return (int) ((num - min) * len / (max - min));
	}
}
```


###  （九）工程中的综合排序算法

- 首先会判断数组的长度（一般界限为 60）；
    - 如果数组长度较短，一般使用插入排序，虽然插入排序的时间复杂度为：$O({N}^{2})$ 但是因为数据量较小，因此 $O({N}^{2})$ 比 $log_{2}^{N}$不会差距很大，但是因为插入排序的常数项很低，因此整体的时间复杂度较低；
    - 如果数组长度较长
        - 首先判断数组中装的数据类型
            - 如果是基础数据类型：使用快排，因为其相同值没有区分，因此不必考虑稳定性；
            - 如果是自定义数据类型：使用归并排序，因为即使相同值也是有区别的，要保证稳定性；
        - 然后如果使用快排的话，因为快排使用分治划分的思想，因此在递归的时候如果划分多次之后数组长度减少到一定长度（例如 60），则直接使用插入排序；

